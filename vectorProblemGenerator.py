#========================================
# CSE 4303 / CSE 5365 Computer Graphics
# Brian A. Dalio
# 2018 Mar 19
# Version 1.2.2
#========================================
HELP = """\
== vectorProblemGenerator.py, version 1.2.2, 2018 Mar 19. ==
Generates any number of problem / answer sets for the
following operations (in two or three dimensions):

  * Perpendicular to a vector.
  * Norm (length) of a vector.
  * Normalization of a vector.  (Conversion to a unit vector.)
  * Dot product of two vectors.
  * Angle between two vectors.
  * Cross product of two vectors (3D only)
  * Projection of a vector onto another vector.
  * Projection of a vector onto a perpendicular to another vector.

The last two operations (projections) constitute the decomposition
of a vector into two perpendicular components.

#----------------------------------------
Sample command line:
  python3 vectorProblemGenerator.py -n5 123456 problems -3d

    -n5      -- generate 5 problems/answers.  Default is 10.

    123456   -- Seed for random number generator.  Default is
      based on the time of day.  You can specify the seed to get
      the same problems / answers from a previous run.  For
      example, if you generated only the problems, you can then
      get the answers to those problems by using the same seed.
      Should be an int.

    problems -- Generate problems only.  Use 'both' to get both
      answers and problems or 'answers' to get answers only.

    -3d -- Uses three dimensional vectors.  Use '-2d' to get
      two-dimensional vectors.  The default is two dimensions.

Here's the header line generated for that sample command line.
Notice that the seed is listed along with three 'check' numbers.

#==PROBLEM SET====Set 123456, check [574, 103, 458]===================

This is the corresponding command line to get the answers for the
problems generated by that previous command line:

  python3 vectorProblemGenerator.py -n5 123456 answers

Voila the header line generated for the answers:

#==ANSWER SET=====Set 123456, check [574, 103, 458]===================

Notice that the set number (seed) is the same as are the three
'check' numbers.  That confirms that the answers will match the
previously generated problems.

#----------------------------------------
Other options:
    -crossproduct -- Generate cross product problems.  By
      default, only simple vector problems are generated.
      This option overrides the generation of simple vector
      problems, so if you want both kinds, use -vector as
      well.  This option forces 3D vectors.

    -small        -- Generate vectors whose elements are
      all in the range [ -9 .. 9 ].  The default is for 
      vector elements to be in the range [ -99 .. 99 ].
    
    -vector       -- See the -crossproduct option above.
"""
#========================================
import datetime
import math
import random
import sys

#========================================
def _effector( w, d = None ) :
  if ( d is None ) :
    return '%' + str( w ) + 'd'

  else :
    return '%' + str( w ) + '.' + str( d ) + 'f'

# How wide various kinds of things need to be so that the
# maximum width of any possible value can be satisfied.
ELEM_DIGITS         = 2 + 1               # Two digits and a sign.
ELEM_SQR_DIGITS     = 2*ELEM_DIGITS - 1   # Double the digits and a sign.
ELEM_SQR_SUM_DIGITS = ELEM_SQR_DIGITS + 1 # Just one more digit.
ELEM_4S_DIGITS      = 2*ELEM_SQR_SUM_DIGITS - 1
FLOAT_WIDTH         = 7
FLOAT_DIGITS        = 3
FLOAT2_WIDTH        = 9
FLOAT2_DIGITS       = 6

# C-style format effector for each kind of thing that gets printed.
EFF_D      = _effector( ELEM_DIGITS )
EFF_SD     = _effector( ELEM_SQR_DIGITS )
EFF_SSD    = _effector( ELEM_SQR_SUM_DIGITS )
EFF_4SD    = _effector( ELEM_4S_DIGITS )
EFF_FLT    = _effector( FLOAT_WIDTH, FLOAT_DIGITS )
EFF_FLT2   = _effector( FLOAT2_WIDTH, FLOAT2_DIGITS )

# A string of _ of the length of each kind of thing that gets printed.
BLANK_D    = '_'*ELEM_DIGITS
BLANK_SD   = '_'*ELEM_SQR_DIGITS
BLANK_SSD  = '_'*ELEM_SQR_SUM_DIGITS
BLANK_4SD  = '_'*ELEM_4S_DIGITS
BLANK_FLT  = '_'*FLOAT_WIDTH
BLANK_FLT2 = '_'*FLOAT2_WIDTH

#========================================
def vectorInitial( dimensions, vName, v, blank = False, makePerp = False ) :
  elems  = ', '.join( [ EFF_D % e for e in v ] )
  elemsB = ', '.join( [ BLANK_D ]*dimensions )

  if ( dimensions == 2 ) :
    pV = ( -v[1], v[0] )

  else :
    if ( v[0] == 0 and v[1] == 0 ) :
      # Both x and y were 0, so we have to
      # use z to make the perpendicular.
      pV = ( -v[2], 0, 0 )

    else :
      # At least one of x and y was non-zero
      # so we can make the perpendicular with z=0.
      pV = ( -v[1], v[0], 0 )

  #----------
  if ( blank ) :
    result = None

    elemsMaybe   = elemsB
    elemsP       = elemsB
    elemsTheV    = elemsB

    dotSelfElems = ', '.join( [ BLANK_D + '×' + BLANK_D ]*dimensions )
    dotSelfSums  = ' + '.join( [ BLANK_SD ]*dimensions )
    dotSelf      = BLANK_SSD
    dotSelfRoot  = BLANK_FLT
    hat          = ', '.join( [ BLANK_FLT ]*dimensions )

  else :
    elemsMaybe   = elems
    elemsP       = ', '.join( [ EFF_D % e for e in pV ] )

    theV         = pV if makePerp else v
    elemsTheV    = elemsP if makePerp else elems

    rProds       = [ e*e for e in theV ]
    rDotSelf     = sum( rProds )
    rDotSelfRoot = math.sqrt( rDotSelf )
    rHat         = [ e / rDotSelfRoot for e in theV ]

    result = ( theV, rDotSelfRoot, rHat )

    dotSelfElems = ', '.join( [ ( EFF_D % e ) + '×' + ( EFF_D % e ) for e in theV ] )
    dotSelfSums  = ' + '.join( [ EFF_SD % e for e in rProds ] )
    dotSelf      = EFF_SSD % rDotSelf
    dotSelfRoot  = EFF_FLT % rDotSelfRoot
    hat          = ', '.join( [ EFF_FLT % e  for e in rHat ] )

  #----------
  PAD1 = ' '*(len(vName) + 2 )
  PAD2 = ' '*(len(vName) + 5 )

  if ( makePerp ) :
    print( '%s = ⊥ [ %s ]ᵀ = [ %s ]ᵀ' % ( vName, elemsMaybe, elemsP ) )

  else :
    print( '%s = [ %s ]ᵀ' % ( vName, elems ) )

  print( '‖%s‖ ≡ √( %s·%s ) = √( %s )' % ( vName, vName, vName, dotSelfElems ) )
  print( PAD1, '= √( %s ) = √( %s ) = %s' % ( dotSelfSums, dotSelf, dotSelfRoot ) )
  print( 'hat(%s) ≡ %s/‖%s‖ = [ %s ]ᵀ/%s' % ( vName, vName, vName, elemsTheV, dotSelfRoot ) )

  print( PAD2, '= [ %s ]ᵀ' % ( hat ) )

  #----------
  return result

def vectorDotAndTheta( dimensions, v0Info, v1Info, blank = False, thetaName = 'θ' ) :
  if ( blank ) :
    result = None

    v0Name = v0Info
    v1Name = v1Info

    v0Elems   = ', '.join( [ BLANK_D ]*dimensions )
    v1Elems   = ', '.join( [ BLANK_D ]*dimensions )
    dotAdd    = ' + '.join( [ BLANK_D + '×' + BLANK_D ]*dimensions )
    dotProds  = ' + '.join( [ BLANK_SD ]*dimensions )
    dotSum    = BLANK_SSD
    eNV0      = BLANK_FLT
    eNV1      = BLANK_FLT
    eNV0NV1   = BLANK_FLT
    eCos      = BLANK_FLT2
    eTheta    = BLANK_FLT
    eThetaDeg = BLANK_FLT

  else :
    ( v0Name, v0, nv0 ) = v0Info
    ( v1Name, v1, nv1 ) = v1Info

    rDotProds = [ a*b for a, b in zip( v0, v1 ) ]
    rDotSum   = sum( rDotProds )

    # θ is the angle between v0 and v1
    cosTheta  = rDotSum / ( nv0*nv1 )    # cos θ ≡ v0·v1 / ( ‖v0‖*‖v1‖ )
    theta     = math.acos( cosTheta )    # Get θ from cos θ.
    thetaDeg  = math.degrees( theta )    # Get θ in degrees.

    v0Elems   = ', '.join( [ EFF_D % e for e in v0 ] )
    v1Elems   = ', '.join( [ EFF_D % e for e in v1 ] )
    dotAdd    = ' + '.join( [ ( EFF_D % a ) + '×' + ( EFF_D % b ) for a, b in zip( v0, v1 ) ] )
    dotProds  = ' + '.join( [ EFF_SD % e for e in rDotProds ] )
    dotSum    = EFF_SSD % rDotSum
    eNV0      = EFF_FLT % nv0
    eNV1      = EFF_FLT % nv1
    eNV0NV1   = EFF_FLT % ( nv0 * nv1 )
    eCos      = EFF_FLT2 % cosTheta
    eTheta    = EFF_FLT % theta
    eThetaDeg = EFF_FLT % thetaDeg

    result = ( cosTheta )

  #----------
  PAD1 = ' '*( 2 )
  PAD2 = ' '*( len( v0Name ) + len( v1Name ) + 1 + 2 )
  PAD3 = ' '*( 2 )
  PAD4 = ' '*( len( thetaName ) + 4 + 2 )
  PAD5 = ' '*( len( thetaName ) + ( 3 if len( thetaName ) > 1 else 5 ) )

  print( '%s·%s%s≡ [ %s ]ᵀ · [ %s ]ᵀ' % ( v0Name, v1Name, PAD1, v0Elems, v1Elems ) )
  print( '%s= %s' % ( PAD2, dotAdd ) )
  print( '%s= %s = %s' % ( PAD2, dotProds, dotSum ) )

  print( 'cos %s%s≡ (%s·%s)/(‖%s‖×‖%s‖) = %s/(%s×%s)' % (
    thetaName, PAD3, v0Name, v1Name, v0Name, v1Name, dotSum, eNV0, eNV1 ) )

  print( '%s= %s/%s = %s' % ( PAD4, dotSum, eNV0NV1, eCos ) )
  print( '%s%s= arccos( %s ) = %s rad or %s°' % ( thetaName, PAD5, eCos, eTheta, eThetaDeg ) )

  return result

def vectorProjection( dimensions, v0Info, v1Info, cosTheta, blank = False, thetaName = 'θ' ) :
  if ( blank ) :
    v0Name = v0Info
    v1Name = v1Info

    eNV0   = BLANK_FLT
    eCos   = BLANK_FLT2
    eNProj = BLANK_FLT
    eHat1  = ', '.join( [ BLANK_FLT ]*dimensions )
    eProj  = ', '.join( [ BLANK_FLT ]*dimensions )

    result = None

  else :
    ( v0Name, _,  nv0, _   ) = v0Info
    ( v1Name, _,  _,   hv1 ) = v1Info

    # The projection of v0 onto v1 is written v0 → v1.
    nv0ProjV1 = nv0 * cosTheta          # ‖ v0 → v1 ‖ ≡ ‖v0‖*cos θ.

    # The vector v0 → v1 ≡ ‖v0 → v1‖ hat( v1 )
    v0ProjV1 = [ nv0ProjV1*e for e in hv1 ]

    eNV0   = EFF_FLT % nv0
    eCos   = EFF_FLT2 % cosTheta
    eNProj = EFF_FLT % nv0ProjV1
    eHat1  = ', '.join( [ EFF_FLT % e for e in hv1 ] )
    eProj  = ', '.join( [ EFF_FLT % e for e in v0ProjV1 ] )

    result = ( nv0ProjV1, v0ProjV1 )

  #----------
  PAD1 = ' '*2
  PAD2 = ' '*( 2 + 2 )
  PAD3 = ' '*( len( v0Name ) + len( v1Name ) + 5 + 2 )

  print( '‖%s → %s‖%s≡ ‖%s‖ cos %s = %s×%s = %s' % (
    v0Name, v1Name, PAD1, v0Name, thetaName, eNV0, eCos, eNProj ) )

  print( '%s → %s%s≡ ‖%s → %s‖ hat(%s)' % (
    v0Name, v1Name, PAD2, v0Name, v1Name, v1Name ) )

  print( '%s= %s×[ %s ]ᵀ' % (
    PAD3, eNProj, eHat1 ) )

  print( '%s= [ %s ]ᵀ' % (
    PAD3, eProj ) )

  return result

def crossProduct( v0Info, v1Info, blank = False, showVectors = False ) :
  ( v0Name, v0 ) = v0Info
  ( v1Name, v1 ) = v1Info

  if ( blank ) :
    basisChars = [ '_' ]*3
    basisNames = '  '.join( [ '_'*ELEM_DIGITS ]*3 )

    # If this problem is being printed _without_ the vector problems
    # also, we have to print the vectors so the user knows them.
    # Otherwise the entire problem is blank.
    v0Str   = [ BLANK_D ]*3
    v1Str   = [ BLANK_D ]*3

    if ( showVectors ) :
      v0Elems = ', '.join( [ EFF_D % e for e in v0 ] )
      v1Elems = ', '.join( [ EFF_D % e for e in v1 ] )

    else :
      v0Elems = ', '.join( v0Str )
      v1Elems = ', '.join( v1Str )

    M0ProdsStr = [ BLANK_SD ]*2
    M1ProdsStr = [ BLANK_SD ]*2
    M2ProdsStr = [ BLANK_SD ]*2

    detValsStr   = [ BLANK_SSD ]*3
    crossProdStr = [ BLANK_SSD ]*3
    crPrdSqStr   = [ BLANK_4SD ]*3
    nsqCrPrdStr  = BLANK_4SD
    nCrPrdStr    = BLANK_FLT

    nV0Str      = BLANK_FLT
    nV1Str      = BLANK_FLT
    #nV0nV1Str   = BLANK_FLT
    sinThetaStr = BLANK_FLT2
    thetaStr    = BLANK_FLT
    thetaDegStr = BLANK_FLT

    result = None

  else :
    fmt = '^%ds' % ( ELEM_DIGITS )
    basisChars = [ 'i', 'j', 'k' ]
    basisNames = '  '.join( format( b, fmt ) for b in basisChars )

    v0Str   = [ EFF_D % e for e in v0 ]
    v1Str   = [ EFF_D % e for e in v1 ]

    v0Elems = ', '.join( v0Str )
    v1Elems = ', '.join( v1Str )

    nV0     = math.sqrt( sum( [ e*e for e in v0 ] ) )
    nV0Str  = EFF_FLT % nV0
    nV1     = math.sqrt( sum( [ e*e for e in v1 ] ) )
    nV1Str  = EFF_FLT % nV1

    nV0nV1  = nV0 * nV1
    #nV0nV1Str = EFF_FLT % nV0nV1

    M0Prods = [ v0[1]*v1[2], v0[2]*v1[1] ]
    M1Prods = [ v0[0]*v1[2], v0[2]*v1[0] ]
    M2Prods = [ v0[0]*v1[1], v0[1]*v1[0] ]

    detVals   = [ M0Prods[0]-M0Prods[1], M1Prods[0]-M1Prods[1], M2Prods[0]-M2Prods[1] ]
    crossProd = [ detVals[0], -detVals[1], detVals[2] ]
    crPrdSq   = [ e*e for e in crossProd ]
    nsqCrPrd  = sum( crPrdSq )
    nCrPrd    = math.sqrt( nsqCrPrd )

    sinTheta  = nCrPrd / nV0nV1

    # We can't get θ this easily because in the range [ 0..180 ],
    # sin θ is ambiguous, going from 0 → 1 → 0.  Therefore, an
    # angle θ cannot be distinguished from its supplement (180-θ).
    # We get an accurate θ here by using the dot product
    # relation θ = arccos( (v0·v1)/(‖v0‖×‖v1‖) ).
    #theta     = math.asin( sinTheta )

    dotProd   = sum( [ a*b for a, b in zip( v0, v1 ) ] )
    cosTheta  = dotProd/(nV0*nV1)
    theta     = math.acos( cosTheta )

    sinThetaStr = EFF_FLT2 % sinTheta
    thetaStr  = EFF_FLT % theta
    thetaDegStr = EFF_FLT % ( math.degrees( theta ) )

    M0ProdsStr = [ EFF_SD % e for e in M0Prods ]
    M1ProdsStr = [ EFF_SD % e for e in M1Prods ]
    M2ProdsStr = [ EFF_SD % e for e in M2Prods ]

    detValsStr   = [ EFF_SSD % e for e in detVals ]
    crossProdStr = [ EFF_SSD % e for e in crossProd ]
    crPrdSqStr   = [ EFF_4SD % e for e in crPrdSq ]
    nsqCrPrdStr  = EFF_4SD % ( nsqCrPrd )
    nCrPrdStr    = EFF_FLT % ( nCrPrd )

    result = ( crossProd )

  v0MElems = '  '.join( v0Str )
  v1MElems = '  '.join( v1Str )

  M0Str    = [ '  '.join( [ v0Str[1], v0Str[2] ] ), '  '.join( [ v1Str[1], v1Str[2] ] ) ]
  M1Str    = [ '  '.join( [ v0Str[0], v0Str[2] ] ), '  '.join( [ v1Str[0], v1Str[2] ] ) ]
  M2Str    = [ '  '.join( [ v0Str[0], v0Str[1] ] ), '  '.join( [ v1Str[0], v1Str[1] ] ) ]

  #----------
  nameStr   = '%s×%s' % ( v0Name, v1Name )
  frontStrA = '%s = [ %s ]ᵀ×[ %s ]ᵀ' % ( nameStr, v0Elems, v1Elems )
  frontStrB = '‖%s‖' % ( nameStr )
  PAD1 = ' '*( len( frontStrA ) + 7 )
  PAD2 = ' '*( len( nameStr ) )
  PAD3 = ' '*( len( nameStr ) + 9 )
  PAD4 = ' '*( len( frontStrB ) )

  print(        '%s| %s |' % ( PAD1, basisNames ) )
  print( '%s ≡ det | %s |' % ( frontStrA, v0MElems ) )
  print(        '%s| %s |' % ( PAD1, v1MElems ) )

  print(          '%s| %s |         | %s |         | %s |' % (
    PAD3, M0Str[0], M1Str[0], M2Str[0] ) )
  print( '%s = %s·det | %s | - %s·det | %s | + %s·det | %s |' % (
    PAD2, basisChars[0], M0Str[1], basisChars[1], M1Str[1], basisChars[2], M2Str[1] ) )

  print( '%s = %s(%s·%s - %s·%s)-%s(%s·%s - %s·%s)+%s(%s·%s - %s·%s)' % (
    PAD2,
    basisChars[0], v0Str[1], v1Str[2], v0Str[2], v1Str[1],
    basisChars[1], v0Str[0], v1Str[2], v0Str[2], v1Str[0],
    basisChars[2], v0Str[0], v1Str[1], v0Str[1], v1Str[0] ) )

  print( '%s = %s(  %s - %s)  -%s(  %s - %s)  +%s(  %s - %s)' % (
    PAD2,
    basisChars[0], M0ProdsStr[0], M0ProdsStr[1],
    basisChars[1], M1ProdsStr[0], M1ProdsStr[1],
    basisChars[2], M2ProdsStr[0], M2ProdsStr[1] ) )

  print( '%s = %s(%s)           -%s(%s)           +%s(%s)' % (
    PAD2,
    basisChars[0], detValsStr[0],
    basisChars[1], detValsStr[1],
    basisChars[2], detValsStr[2] ) )

  print( '%s = [ %s ]ᵀ' % (
    PAD2, ', '.join( crossProdStr ) ) )

  #----------
  print()

  print ( '%s = ‖[ %s ]ᵀ‖' % ( frontStrB, ', '.join( crossProdStr ) ) )

  print ( '%s = √( %s )' % (
    PAD4, ' + '.join( [ e+'^2' for e in crossProdStr ] ) ) )

  print ( '%s = √( %s )' % ( PAD4, ' + '.join( crPrdSqStr ) ) )

  print ( '%s = √( %s )' % ( PAD4, nsqCrPrdStr ) )

  print ( '%s = %s' % ( PAD4, nCrPrdStr ) )

  #----------
  print()

  print( '%s = ‖%s‖×‖%s‖×sin θ' % ( frontStrB, v0Name, v1Name ) )
  print( '%s = %s × %s × sin( %s rad or %s° )' % ( PAD4, nV0Str, nV1Str, thetaStr, thetaDegStr ) )
  print( '%s = %s × %s ×  %s' % ( PAD4, nV0Str, nV1Str, sinThetaStr ) )
  print( '%s = %s          ∎' % ( PAD4, nCrPrdStr ) )

  # One can't compute the angle between two vectors using the
  # cross product because sin is ambiguous in the range [ 0..180 ].
  # This means that if the angle is 90 < θ < 180, it will
  # instead be computed as its supplement, 180-θ.
  # To get an accurate θ, use θ = arccos( v0·v1 / ( ‖v0‖*‖v1‖ ) ).
  # The dot product preserves the quadrant as it will return a
  # value in the range [-1 .. 1].
  #print( 'sin θ = %s / (‖%s‖×‖%s‖)' % ( frontStrB, v0Name, v1Name ) )
  #print( '      = %s / ( %s · %s )' % ( nCrPrdStr, nV0Str, nV1Str ) )
  #print( '      = %s / %s = %s' % ( nCrPrdStr, nV0nV1Str, sinThetaStr ) )
  #print( 'θ     = arcsin( %s ) = %s rad or %s°' % ( sinThetaStr, thetaStr, thetaDegStr ) )

  #----------
  return result

#========================================
def generateAnswers( options ) :
  content     = options[ 'content' ]
  dimensions  = options[ 'dimensions' ]
  header      = options[ 'header' ]
  numExamples = options[ 'numExamples' ]
  vectors     = options[ 'vectors' ]

  print( '#==ANSWER SET=====%s' % ( header + '='*( 70 - 18 - len( header ) ) ) )

  for i in range( 1, numExamples+1 ) :
    v0 = vectors[ i*2 + 0 ]             # Vector 0 (v0)
    v1 = vectors[ i*2 + 1 ]             # Vector 1 (v1)

    print( '#--Answer %2d------%s' % ( i, '-'*( 70 - 18 ) ) )

    if ( 'vector' in content ) :
      # ----- v0's data ...
      ( _, nv0, hv0 ) = vectorInitial( dimensions, 'v0', v0 )
      print()
      ( _, _,   _   ) = vectorInitial( dimensions, '⊥ v0', v0, makePerp = True )
      print( '- - - - - - - - - - - - - - - - - - - - \n' )

      # ----- v1's data ...
      ( _, nv1, hv1 ) = vectorInitial( dimensions, 'v1', v1 )
      print()
      ( pv1, npv1, hpv1 ) = vectorInitial( dimensions, '⊥ v1', v1, makePerp = True )
      print( '- - - - - - - - - - - - - - - - - - - - \n' )

      # θ is the angle between v0 and v1
      ( cosTheta ) = vectorDotAndTheta( dimensions,
        ( 'v0', v0, nv0 ), ( 'v1', v1, nv1 ) )
      print()
      vectorProjection( dimensions,
        ( 'v0', v0, nv0, hv0 ), ( 'v1', v1, nv1, hv1 ), cosTheta )
      print( '- - - - - - - - - - - - - - - - - - - - \n' )

      # ⊥θ is the angle between v0 and ⊥v1
      ( cosPTheta ) = vectorDotAndTheta( dimensions,
        ( 'v0', v0, nv0 ), ( '⊥ v1', pv1, npv1 ),
        thetaName = '⊥ θ' )

      print()

      vectorProjection( dimensions,
        ( 'v0', v0, nv0, hv0 ), ( '⊥ v1', pv1, npv1, hpv1 ),
        cosPTheta, thetaName = '⊥ θ' )
      print( '- - - - - - - - - - - - - - - - - - - - \n' )

    if ( 'crossproduct' in content ) :
      crossProduct( ( 'v0', v0 ), ( 'v1', v1 ) )
      print( '- - - - - - - - - - - - - - - - - - - - \n' )

  print( '#' + '='*69 )
  print()

#========================================
def generateProblems( options ) :
  content     = options[ 'content' ]
  dimensions  = options[ 'dimensions' ]
  header      = options[ 'header' ]
  numExamples = options[ 'numExamples' ]
  vectors     = options[ 'vectors' ]

  print( '#==PROBLEM SET====%s' % ( header + '='*( 70 - 18 - len( header ) ) ) )

  for i in range( 1, numExamples+1 ) :
    v0 = vectors[ i*2 + 0 ]
    v1 = vectors[ i*2 + 1 ]

    print( '#--Problem %2d-----%s' % ( i, '-'*( 70 - 18 ) ) )

    if ( 'vector' in content ) :
      # ----- v0, ⊥v0 data ...
      vectorInitial( dimensions, 'v0', v0, blank = True )
      print()
      vectorInitial( dimensions, '⊥ v0', v0, makePerp = True, blank = True )
      print( '- - - - - - - - - - - - - - - - - - - - \n' )

      # ----- v1, ⊥v1 data ...
      vectorInitial( dimensions, 'v1', v1, blank = True )
      print()
      vectorInitial( dimensions, '⊥ v1', v1, makePerp = True, blank = True )
      print( '- - - - - - - - - - - - - - - - - - - - \n' )

      # θ is the angle between v0 and v1
      vectorDotAndTheta( dimensions, 'v0', 'v1', blank = True )
      print()
      vectorProjection( dimensions, 'v0', 'v1', None, blank = True )
      print( '- - - - - - - - - - - - - - - - - - - - \n' )

      # ⊥θ is the angle between v0 and ⊥v1
      vectorDotAndTheta( dimensions, 'v0', '⊥ v1', blank = True, thetaName = '⊥ θ' )
      print()
      vectorProjection( dimensions, 'v0', '⊥ v1', None, blank = True, thetaName = '⊥ θ' )
      print( '- - - - - - - - - - - - - - - - - - - - \n' )

    if ( 'crossproduct' in content ) :
      # If the vector side of the problem is _not_ printed, we have to
      # show the vectors in the cross product, otherwise the entire
      # problem is blank.
      crossProduct( ( 'v0', v0 ), ( 'v1', v1 ), blank = True, showVectors = 'vector' not in content )
      print( '- - - - - - - - - - - - - - - - - - - - \n' )

#========================================
def getSimpleOptions( params ) :
  ( args, options ) = params
  argsOut = list( args )

  options[ 'content' ]    = set()
  options[ 'dimensions' ] = 2
  options[ 'mode' ]       = set()
  options[ 'numExamples'] = 10
  options[ 'range' ]      = 100
  options[ 'small' ]      = False

  now = datetime.datetime.now()
  options[ 'seed' ]       = (now.second+10)*10000 + now.minute*100 + now.hour

  for arg in args :
    upper = arg.upper()

    try :
      options[ 'seed' ] = int( arg )
      argsOut.remove( arg )
      continue

    except :
      pass

    if ( '-ANSWERS'.startswith( upper ) ) :
      options[ 'mode' ].add( 'answers' )
      argsOut.remove( arg )

    elif ( '-BOTH'.startswith( upper ) ) :
      options[ 'mode' ] |= { 'answers', 'problems' }
      argsOut.remove( arg )

    elif ( '-CROSSPRODUCT'.startswith( upper ) ) :
      options[ 'content' ].add( 'crossproduct' )
      argsOut.remove( arg )

    elif ( upper.startswith( '-N' ) ) :
      num = arg[ 2: ]
      try :
        options[ 'numExamples'] = int( num )
        argsOut.remove( arg )

      except :
        raise ValueError( 'Bad number of examples specification \'%s\'.' % ( arg ) )

    elif ( '-PROBLEMS'.startswith( upper ) ) :
      options[ 'mode' ].add( 'problems' )
      argsOut.remove( arg )

    elif ( '-SMALL'.startswith( upper ) ) :
      options[ 'small' ] = True
      options[ 'range' ] = 10
      argsOut.remove( arg )

    elif ( '-VECTOR'.startswith( upper ) ) :
      options[ 'content' ].add( 'vector' )
      argsOut.remove( arg )

    elif ( upper in [ '-2D', '-3D' ] ) :
      options[ 'dimensions' ] = 2 if upper == '-2D' else 3
      argsOut.remove( arg )

  #----------
  if ( len( options[ 'content' ] ) == 0 ) :
    options[ 'content' ] = { 'vector' }

  if ( len( options[ 'mode' ] ) == 0 ) :
    options[ 'mode' ] |= { 'answers', 'problems' }

  return ( argsOut, options )

def main() :
  args = sys.argv[ 1: ]
  if ( '-h' in args or '--help' in args ) :
    print( HELP )
    sys.exit( 0 )

  #----------------------------------------
  params = ( args, dict() )

  try :
    ( args, options ) = getSimpleOptions( params )

  except ValueError as e :
    print( 'Option error: %s' % e )
    sys.exit( 1 )

  if ( len( args ) > 0 ) :
    print( 'Ignoring some arguments, %s.' % ( args ) )

  if ( 'crossproduct' in options[ 'content' ] ) :
    # Cross products are for three dimensions only.
    options[ 'dimensions' ] = 3

  #----------------------------------------
  # Set the random number seed and generate the check header.
  random.seed( options[ 'seed' ] )
  deck = list( range( 100, 1000 ) )
  random.shuffle( deck )

  smallStr = '(small)' if options[ 'small' ] else ''
  options[ 'header' ] = 'Set %d%s, check %s' % ( options[ 'seed' ], smallStr, deck[ 0 : 3 ] )

  # Build list of potential vectors, 2D or 3D.
  reqNum   = options[ 'numExamples' ] * options[ 'dimensions' ] * 2
  deck     = list( range( 0, options[ 'range' ] ) ) * reqNum
  negDeck  = [ -d for d in deck ]
  deck    += negDeck

  random.shuffle( deck )

  if ( options[ 'dimensions' ] == 2 ) :
    vectors = [ ( x, y ) for ( x, y ) in zip( deck[::2], deck[1::2] ) if ( x != 0 or y != 0 ) ]

  else :
    vectors = [ ( x, y, z ) for ( x, y, z )
      in zip( deck[::3], deck[1::3], deck[2::3] )
      if ( x != 0 or y != 0 or z != 0 ) ]

  options[ 'vectors' ] = vectors

  #----------------------------------------
  # Generate problems first, then answers.

  if ( 'problems' in options[ 'mode' ] ) :
    generateProblems( options )

  if ( 'answers' in options[ 'mode' ] ) :
    generateAnswers( options )

#----------------------------------------
if ( __name__ == '__main__' ) :
  main()

#========================================
